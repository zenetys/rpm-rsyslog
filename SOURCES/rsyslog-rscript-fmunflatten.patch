From ed8c6f6eeabe5ca21fcd3174af806577b995f7ce Mon Sep 17 00:00:00 2001
From: Julien Thomas <jthomas@zenetys.com>
Date: Sun, 16 Aug 2020 07:16:08 +0200
Subject: [PATCH] fmunflatten: rscript function to unflatten keys of a JSON
 object

---
 Makefile.am                       |   4 +
 configure.ac                      |  15 ++
 contrib/fmunflatten/Makefile.am   |   5 +
 contrib/fmunflatten/fmunflatten.c | 237 ++++++++++++++++++++++++++++++
 4 files changed, 261 insertions(+)
 create mode 100644 contrib/fmunflatten/Makefile.am
 create mode 100644 contrib/fmunflatten/fmunflatten.c

diff --git a/Makefile.am b/Makefile.am
index 0e1c0195c..4d60e55f7 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -215,6 +215,10 @@ if ENABLE_FMHASH
 SUBDIRS += contrib/fmhash
 endif
 
+if ENABLE_FMUNFLATTEN
+SUBDIRS += contrib/fmunflatten
+endif
+
 if ENABLE_OMKAFKA
 SUBDIRS += plugins/omkafka
 endif
diff --git a/configure.ac b/configure.ac
index 457f23e0e..4ef1c6169 100644
--- a/configure.ac
+++ b/configure.ac
@@ -388,6 +388,19 @@ if test "$enable_fmhash_xxhash" = "yes"; then
 fi
 
 
+# rscript function unflatten
+AC_ARG_ENABLE(fmunflatten,
+	[AS_HELP_STRING([--enable-fmunflatten],[Enable fmunflatten support @<:@default=yes@:>@])],
+        [case "${enableval}" in
+         yes) enable_fmunflatten="yes" ;;
+          no) enable_fmunflatten="no" ;;
+           *) AC_MSG_ERROR(bad value ${enableval} for --enable-fmunflatten) ;;
+         esac],
+	[enable_fmunflatten=yes]
+)
+AM_CONDITIONAL(ENABLE_FMUNFLATTEN, test x$enable_fmunflatten = xyes)
+
+
 #gssapi
 AC_ARG_ENABLE(gssapi_krb5,
 	[AS_HELP_STRING([--enable-gssapi-krb5],[Enable GSSAPI Kerberos 5 support @<:@default=no@:>@])],
@@ -2608,6 +2621,7 @@ AC_CONFIG_FILES([Makefile \
     contrib/mmdarwin/Makefile \
 		contrib/omhttp/Makefile \
 		contrib/fmhash/Makefile \
+		contrib/fmunflatten/Makefile \
 		contrib/pmsnare/Makefile \
 		contrib/pmpanngfw/Makefile \
 		contrib/pmaixforwardedfrom/Makefile \
@@ -2748,6 +2762,7 @@ echo "---{ function modules }---"
 echo "    fmhttp enabled:                           $enable_fmhttp"
 echo "    fmhash enabled:                           $enable_fmhash"
 echo "    fmhash with xxhash enabled:               $enable_fmhash_xxhash"
+echo "    fmunflatten enabled:                      $enable_fmunflatten"
 echo
 echo "---{ debugging support }---"
 echo "    distcheck workaround enabled:             $enable_distcheck_workaround"
diff --git a/contrib/fmunflatten/Makefile.am b/contrib/fmunflatten/Makefile.am
new file mode 100644
index 000000000..b3d27e482
--- /dev/null
+++ b/contrib/fmunflatten/Makefile.am
@@ -0,0 +1,5 @@
+pkglib_LTLIBRARIES = fmunflatten.la
+fmunflatten_la_SOURCES = fmunflatten.c
+fmunflatten_la_CPPFLAGS = $(PTHREADS_CFLAGS) $(RSRT_CFLAGS) $(JSON_C_CFLAGS)
+fmunflatten_la_LDFLAGS = -module -avoid-version
+fmunflatten_la_LIBADD = $(JSON_C_LIBS)
diff --git a/contrib/fmunflatten/fmunflatten.c b/contrib/fmunflatten/fmunflatten.c
new file mode 100644
index 000000000..b354d6797
--- /dev/null
+++ b/contrib/fmunflatten/fmunflatten.c
@@ -0,0 +1,237 @@
+/*
+ * This is a function module providing ability to unflatten a JSON tree.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *       -or-
+ *       see COPYING.ASL20 in the source distribution
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#include <stdint.h>
+#include <stddef.h>
+#ifndef _AIX
+#include <typedefs.h>
+#endif
+#include <sys/types.h>
+#include <string.h>
+
+#include "config.h"
+#include "rsyslog.h"
+
+#include "errmsg.h"
+#include "msg.h"
+#include "parserif.h"
+#include "module-template.h"
+#include "rainerscript.h"
+
+#ifndef FMUNFLATTEN_KBUFLEN
+#define FMUNFLATTEN_KBUFLEN 256
+#endif
+
+#define _jso_type(x) json_type_to_name(json_object_get_type(x))
+
+MODULE_TYPE_FUNCTION
+MODULE_TYPE_NOKEEP
+DEF_FMOD_STATIC_DATA
+
+struct unflatten_ctx {
+	char *kbuf;
+	size_t kbuf_len;
+	char delim;
+};
+
+/* forward declarations */
+void unflatten_add(struct unflatten_ctx *ctx, struct json_object *dst, const char *key, struct json_object *value);
+void unflatten(struct unflatten_ctx *ctx, struct json_object *src, struct json_object *dst);
+
+void unflatten_add(struct unflatten_ctx *ctx,
+	struct json_object *dst,
+	const char *key,
+	struct json_object *value)
+{
+	const char *p = key;
+	const char *q = p;
+	int depth = 0;
+	size_t klen;
+	struct json_object *o;
+	json_bool exists_already;
+	int create;
+
+	while (1) {
+		while (*q != ctx->delim && *q != '\0')
+			q++;
+		klen = q - p;
+		if (klen + 1 > ctx->kbuf_len) {
+			DBGPRINTF("warning: flat key \"%.20s...\" truncated at depth #%d, buffer too small (max %zd)\n", key, depth, ctx->kbuf_len);
+			klen = ctx->kbuf_len - 1;
+		}
+		memcpy(ctx->kbuf, p, klen);
+		ctx->kbuf[klen] = '\0';
+		exists_already = json_object_object_get_ex(dst, ctx->kbuf, &o);
+
+		if (*q == ctx->delim) {
+			if (!exists_already)
+				create = 1;
+			else if (json_object_is_type(o, json_type_object))
+				create = 0;
+			else {
+				DBGPRINTF("warning: while processing flat key \"%s\" at depth #%d (intermediate node), overriding existing value of type %s by an object\n", key, depth, _jso_type(o));
+				json_object_object_del(dst, ctx->kbuf);
+				create = 1;
+			}
+			if (create) {
+				o = json_object_new_object();
+				json_object_object_add(dst, ctx->kbuf, o);
+			}
+			dst = o;
+			p = q + 1;
+			q = p;
+			depth++;
+		}
+		else if (*q == '\0') {
+			if (json_object_is_type(value, json_type_object)) {
+				if (exists_already) {
+					if (!json_object_is_type(o, json_type_object)) {
+						DBGPRINTF("warning: while processing flat key \"%s\" at depth #%d (final node), overriding existing value of type %s by an object\n", key, depth, _jso_type(o));
+						json_object_object_del(dst, ctx->kbuf);
+						o = json_object_new_object();
+						json_object_object_add(dst, ctx->kbuf, o);
+					}
+				}
+				else {
+					o = json_object_new_object();
+					json_object_object_add(dst, ctx->kbuf, o);
+				}
+				unflatten(ctx, value, o);
+			}
+			else {
+				if (exists_already) {
+					DBGPRINTF("warning: while processing flat key \"%s\" at depth #%d (final node), overriding existing value\n", key, depth);
+					json_object_object_del(dst, ctx->kbuf);
+				}
+				o = jsonDeepCopy(value);
+				json_object_object_add(dst, ctx->kbuf, o);
+			}
+			break;
+		}
+	}
+}
+
+void unflatten(struct unflatten_ctx *ctx,
+	struct json_object *src,
+	struct json_object *dst)
+{
+	struct json_object_iterator it = json_object_iter_begin(src);
+	struct json_object_iterator itEnd = json_object_iter_end(src);
+	const char *key;
+	struct json_object *value;
+
+	while (!json_object_iter_equal(&it, &itEnd)) {
+		key = json_object_iter_peek_name(&it);
+		value = json_object_iter_peek_value(&it);
+		unflatten_add(ctx, dst, key, value);
+		json_object_iter_next(&it);
+	}
+}
+
+static void ATTR_NONNULL()
+doFunc_unflatten(struct cnffunc *__restrict__ const func,
+	struct svar *__restrict__ const ret,
+	void *__restrict__ const usrptr,
+	wti_t *__restrict__ const pWti)
+{
+	struct svar src_var;
+	struct svar delim_var;
+
+	char kbuf[FMUNFLATTEN_KBUFLEN];
+	struct unflatten_ctx ctx = {
+		.kbuf = kbuf,
+		.kbuf_len = sizeof(kbuf),
+		.delim = 0
+	};
+
+	cnfexprEval(func->expr[0], &src_var, usrptr, pWti);
+	cnfexprEval(func->expr[1], &delim_var, usrptr, pWti);
+
+	/* check argument 2 (delim) */
+	if (delim_var.datatype == 'S' && es_strlen(delim_var.d.estr) == 1)
+		ctx.delim = *es_getBufAddr(delim_var.d.estr);
+	else if (delim_var.datatype == 'N')
+		ctx.delim = delim_var.d.n;
+	if (ctx.delim == 0) {
+		LogError(0, RS_RET_INVALID_PARAMS, "unflatten: error: invalid argument 2 (delim), single character required (as string or decimal charcode)");
+		FINALIZE;
+	}
+
+	/* just return a copy of argument 1 (src) if it is not a json object */
+	switch (src_var.datatype) {
+		case 'S':
+			ret->datatype = 'S';
+			ret->d.estr = es_strdup(src_var.d.estr);
+			break;
+		case 'N':
+			ret->datatype = 'N';
+			ret->d.n = src_var.d.n;
+			break;
+		case 'J':
+			ret->datatype = 'J';
+			if (json_object_is_type(src_var.d.json, json_type_object)) {
+				ret->d.json = json_object_new_object();
+				unflatten(&ctx, src_var.d.json, ret->d.json);
+			}
+			else
+				ret->d.json = jsonDeepCopy(src_var.d.json);
+			break;
+		default:
+			LogError(0, RS_RET_INVALID_PARAMS, "unflatten: error: invalid argument 1 (src), unsupported datatype %c", src_var.datatype);
+			ret->datatype = 'J';
+			ret->d.json = NULL;
+	}
+
+finalize_it:
+	varFreeMembers(&src_var);
+	varFreeMembers(&delim_var);
+}
+
+static rsRetVal ATTR_NONNULL(1)
+initFunc_unflatten(struct cnffunc *const func)
+{
+	DEFiRet;
+	func->destructable_funcdata = 0;
+	RETiRet;
+}
+
+static struct scriptFunct functions[] = {
+	{ "unflatten", 2, 2, doFunc_unflatten, initFunc_unflatten, NULL },
+	{ NULL, 0, 0, NULL, NULL, NULL } /* last element to check end of array */
+};
+
+BEGINgetFunctArray
+CODESTARTgetFunctArray
+	*version = 1;
+	*functArray = functions;
+ENDgetFunctArray
+
+BEGINmodExit
+CODESTARTmodExit
+ENDmodExit
+
+BEGINqueryEtryPt
+CODESTARTqueryEtryPt
+CODEqueryEtryPt_STD_FMOD_QUERIES
+ENDqueryEtryPt
+
+BEGINmodInit()
+CODESTARTmodInit
+	*ipIFVersProvided = CURR_MOD_IF_VERSION; /* we only support the current interface specification */
+CODEmodInit_QueryRegCFSLineHdlr
+	dbgprintf("rsyslog fmunflatten init called, compiled with version %s\n", VERSION);
+ENDmodInit
-- 
2.21.1

